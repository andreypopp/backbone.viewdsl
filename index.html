<!doctype html>
<meta charset="utf-8">
<title>Backbone.ViewDSL</title>
<link rel="stylesheet" href="app.css">
<div class="main">
<a href="https://github.com/andreypopp/backbone.viewdsl"><img style="position: absolute; top: 0; left:
  0; border: 0;"
  src="https://s3.amazonaws.com/github/ribbons/forkme_left_gray_6d6d6d.png"
  alt="Fork me on GitHub"></a>
<h1>Backbone.ViewDSL</h1>

<p>Backbone.ViewDSL provides declarative view technology on top of Backbone.</p>

<p>The main feature of Backbone.ViewDSL is an extensible DOM templating engine
which allows you to</p>

<ul>
<li>Interpolate string or DOM values</li>
<li>Instantiate sub-views directly from inside templates</li>
<li>Bind data to DOM text nodes or element attributes</li>
<li>Automatically setup references for DOM nodes being rendered</li>
<li>Create custom directives as custom HTML tags or attributes</li>
</ul>

<p>To give a taste of these features there&#39;s a basic example</p>

<pre><code>class App extends Backbone.ViewDSL.View
  template: &quot;&quot;&quot;
    &lt;h1 element-id=&quot;$header&quot;&gt;{{bind:user.name}}&#39;s todos&lt;/h1&gt;
    &lt;view name=&quot;views:UserCard&quot; model=&quot;user&quot;&gt;&lt;/view&gt;
    &lt;foreach collection=&quot;todos&quot;&gt;
      &lt;view name=&quot;views:TodoView&quot;&gt;&lt;/view&gt;
    &lt;/foreach&gt;
    &quot;&quot;&quot;
</code></pre>

<p>This work was mainly inspired by <a href="http://angularjs.org/">Angular.js</a> but tries to stay as close to
Backbone style as possible so it is very easy to use in your application in a
completely non-intrusive way.</p>

<h2>Installation</h2>

<p>You can grab <a href="https://raw.github.com/andreypopp/backbone.viewdsl/master/backbone.viewdsl.js">compiled JavaScript code</a> from the <a href="https://github.com/andreypopp/backbone.viewdsl">repo</a> or use <code>npm</code>:</p>

<pre><code>% npm install backbone.viewdsl
</code></pre>

<p>or <code>bower</code> package managers:</p>

<pre><code>% bower install backbone.viewdsl
</code></pre>

<p>The only dependencies are jQuery, Backbone and underscore.js — if you use one of
the package managers they will be installed automatically, otherwise you should
download them by hand.</p>

<p>Backbone.ViewDSL designed to work in CommonJS environment as well as with any
available AMD loader (such as RequireJS). If you don&#39;t use nor AMD neither
CommonJS loading strategies then all the public API will be available through
the <code>Backbone.ViewDSL</code> browser global.</p>

<h2>Basic usage</h2>

<p>The main usage pattern is exposed via <code>Backbone.ViewDSL.View</code> subclass of
<code>Backbone.View</code> with a custom implementation of <code>render()</code> method.</p>

<p>Usually you want to define a new subclass of it and set a <code>template</code> attribute:</p>

<pre><code>class Message extends Backbone.ViewDSL.View
  template: &quot;&quot;&quot;
    {{greeting}}, {{options.name}}!
    &quot;&quot;&quot;

  greeting: -&gt;
    &#39;Hello&#39;

view = new Message(name: &#39;World&#39;)
view.render()
</code></pre>

<p>This template uses string interpolation to insert <code>options.name</code> value and a
result of <code>greeting()</code> method call inside the DOM text node. That way view&#39;s
<code>el</code> DOM element will have a form of <code>&lt;div&gt;Hello, World!&lt;/div&gt;</code>.</p>

<p>Templates are always rendered in the context of a view so we can reference any
view&#39;s attribute inside them or call any methods without arguments. If you need
to reach some nested attribute or method then you can use usual dotted-path like
<code>a.b.c</code>.</p>

<h2>Sub-views instantiation</h2>

<p>Backbone doesn&#39;t have an opinion on how to manage view hierarchies inside your
application so usually you cook something by yourself.</p>

<p>Backbone.ViewDSL tries to make this task a lot easier by providing you with a
<em>view</em> directive which allows instantiating sub-views right from inside
templates. The directive can be used as a <code>&lt;view&gt;</code> DOM element or <code>view</code> DOM
attribute.</p>

<p>The example would be</p>

<pre><code>class App extends Backbone.ViewDSL.View
  template: &quot;&quot;&quot;
    &lt;view name=&quot;views.Sidebar&quot; model=&quot;user&quot; id=&quot;sidebar&quot;&gt;&lt;/view&gt;
    &lt;footer view=&quot;views.Footer&quot; view-model=&quot;user&quot; view-id=&quot;footer&quot;&gt;&lt;/footer&gt;
    &quot;&quot;&quot;

app = new App
app.render()
</code></pre>

<p>This snippet of code alone makes a lot of things under the hood.</p>

<p>View <code>views.Sidebar</code> will be rendered and <code>app.user</code> will be passed into its
constructor as a <code>model</code> option. After that rendered view will be stored as
<code>app.sidebar</code> attribute.</p>

<p>There&#39;s a bit different story with <code>views.Footer</code> — it also gets <code>app.user</code> as a
constructor <code>model</code> option but instead of creating new DOM node for the view
itself it will reuse <code>&lt;footer&gt;</code> element. That could be useful if you don&#39;t know
before with what kind of element view will be used.</p>

<p>Without using Backbone.ViewDSL all of these would look like this:</p>

<pre><code>class App extends Backbone.View

  render: -&gt;
    this.sidebar = new Sidebar(model: this.user)
    this.sidebar.render()
    this.$el.append(this.sidebar.$el)

    this.footer = new Footer(model: this.user, tagName: &#39;footer&#39;)
    this.footer.render()
    this.$el.append(this.footer.$el)
</code></pre>

<p>The variant which uses <code>Backbone.ViewDSL.ViewDSL</code> looks a lot cleaner, doesn&#39;t
it? Also <code>Backbone.ViewDSL.View</code> keeps track of all instantiated sub-views and
handles its disposal so no memory leaks will happen.</p>

<h2>String and DOM values interpolation</h2>

<p>As it was already shown Backbone.ViewDSL allows you to insert specific
bits of text inside templates. But what&#39;s more interesting — you can also insert
entire DOM elements into templates, even with attached event handlers.</p>

<pre><code>class View extends Backbone.ViewDSL.ViewDSL
  template: &quot;&quot;&quot;
    {{element}} {{jquery}}
    &quot;&quot;&quot;
  element: -&gt;
    document.createElement(&#39;div&#39;)
  jquery: -&gt;
    $(&#39;&lt;div&gt;&#39;).addClass(&#39;klass&#39;)
</code></pre>

<p>Rendered view will have <code>&lt;div&gt;&lt;/div&gt; &lt;div class=&quot;klass&quot;&gt;&lt;/div&gt;</code> as its content.
As you can see you can also insert jQuery objects into template.</p>

<h2>Referencing DOM nodes</h2>

<p>Sometimes you need to reference DOM element from recently rendered template —
you can select it by using <code>this.$</code> method call but a better way would be to use
<code>element-id</code> attribute directive.</p>

<pre><code>class View extends Backbone.ViewDSL.View
  template: &quot;&quot;&quot;
    &lt;div class=&quot;main&quot; element-id=&quot;block&quot;&gt;&lt;/div&gt;
    &quot;&quot;&quot;

view = new View
view.render()
</code></pre>

<p>That way rendered <code>&lt;div&gt;</code> element will be available as <code>view.block</code> attribute.</p>

<h2>Other built-in directives</h2>

<p>There are a couple of other built-in directives — <code>attr-*</code> and <code>class-*</code>
wildcard directives and <code>show-if</code> directive.</p>

<p>The <code>attr-*</code> directive can be used to attach attributes to DOM elements based on
some view&#39;s value. For example given the template</p>

<pre><code>&lt;img attr-src=&quot;model.imageURL&quot;&gt;
</code></pre>

<p>We will get <code>src</code> attribute set to value of <code>model.imageURL</code> view&#39;s attribute.
There&#39;s also a special case for attributes which has boolean interpretation
(<code>checked</code>, <code>contenteditable</code> and so on&hellip;)  — if expression evaluates to
<code>Boolean</code> value then attribute will be present if value is <code>true</code> in case of
<code>false</code> value attribute will not be rendered.</p>

<pre><code>class View extends Backbone.ViewDSL.View
  template: &quot;&quot;&quot;
    &lt;h1 attr-contenteditable=&quot;isEditable&quot;&gt;title&lt;/h1&gt;
    &quot;&quot;&quot;
  isEditable: -&gt;
    this.model.get(&#39;isEditable&#39;) and this.user.canEdit(this.model)
</code></pre>

<p>Note that <code>isEditable</code> method returns boolean value.</p>

<p>The <code>class-*</code> wildcard directive works like a <code>attr-*</code> directive but instead
regulates if element should receive an additional CSS class based on some view&#39;s
attribute or method.</p>

<pre><code>class View extends Backbone.ViewDSL.View
  template: &quot;&quot;&quot;
    &lt;h1 class-editable=&quot;isEditable&quot;&gt;title&lt;/h1&gt;
    &quot;&quot;&quot;
  isEditable: -&gt;
    this.model.get(&#39;isEditable&#39;) and this.user.canEdit(this.model)
</code></pre>

<p>In this example, <code>&lt;h1&gt;</code> will have class <code>editable</code> if and only if <code>isEditable</code>
method evaluates to <code>true</code>.</p>

<p>The last of the built-in directives — <code>show-if</code> controls if element is visible
based on some expression which evaluates to boolean value:</p>

<pre><code>&lt;div show-if=&quot;this.collection.isEmpty&quot;&gt;No items&quot;&lt;/div&gt;
</code></pre>

<p>The <code>&lt;div&gt;</code> element will be displayed only if <code>this.collection.isEmpty()</code>
evaluates to <code>true</code>. Methods <code>$.show()</code> and <code>$.hide()</code> are used to
correspondingly show and hide elements.</p>

<h2>Data-binding</h2>

<p>You want your views to react to underlying data changes but manually maintaining
a set of <code>change</code> event handlers isn&#39;t an option.</p>

<p>For that reason a part of Backbone.ViewDSL directives like <code>attr-*</code>, <code>class-*</code>
and <code>show-if</code> as well as interpolation mechanism allows you to bind their action
on data changes and react to them accordingly.</p>

<p>To turn data-binding on you have to prefix all expressions with <code>bind:</code>
modifier:</p>

<pre><code>class View extends Backbone.ViewDSL.View
  redAllowed: true

  template: &quot;&quot;&quot;
    &lt;div class-red=&quot;bind:isRed&quot;&gt;Hello, {{bind:model.name}}!&lt;/div&gt;
    &quot;&quot;&quot;

  isRed: -&gt;
    this.model.get(&#39;red&#39;) and this.redAllowed

view = new View(model: new Backbone.Model(name: &#39;World&#39;, red: false))
view.render()
</code></pre>

<p>That way rendered view&#39;s <code>el</code> will have</p>

<pre><code>&lt;div&gt;Hello, World!&lt;/div&gt;
</code></pre>

<p>as its <code>innerHTML</code> and it will react to data changes according to directive
actions. So this snippet of code</p>

<pre><code>view.model.set(name: &#39;Commrade&#39;, red: true)
</code></pre>

<p>will result <code>el.innerHTML</code> having different contents</p>

<pre><code>&lt;div class=&quot;red&quot;&gt;Hello, Commrade!&lt;/div&gt;
</code></pre>

<p>Remember that <code>bind:</code> modifier also works with <code>attr-*</code> and <code>show-if</code>
directives.</p>

<h2>Creating custom directives</h2>

<h2>Rendering collections</h2>

<h2>Parametrizable views</h2>
</div>
